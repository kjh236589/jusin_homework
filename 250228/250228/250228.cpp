#include "pch.h"
#include<algorithm>
int main()
{

	return 0;
}
/*
	표준 시퀀스 컨테이너_vector
		- 동적 배열을 기반으로 하는 컨테이너이다.
		- 동적 배열 기반이기에 임의 접근(인덱스 접근)이 가능하다. 탐색에 용이하다.
		- 삽입 시에 앞에서 할 수 없으며 맨 끝에서부터 삽입해 나간다
		- 중간 삽입 및 삭제 시에 삽입 공간 확보, 삭제 공간 활용을 위해 해당 인덱스 이후의 원소 개수만큼 포인터 이동이 발생하기 때문에 느리다.
		원소 개수만큼의 선형적 시간 복잡도
		- 단 맨 끝에서 삽입 삭제 시에는 상수 시간 복잡도(빠르다는 이야기), 왜냐하면 맨 끝에서는 포인터 이돌할 원소들이 없기 때문이다.
		- 동적 배열이므로 배열의 크기를 넘어가는 삽입이 발생할 시에 동적 배열의 재 할당 및 현재 원소들의 복사가 일어나기 때문에 느리다.
		- vector의 원소를 삭제하여도 원소가 존재했던 메모리 공간은 남아있는다.
	
	표준 시퀀스 컨테이너_list
		- 노드를 기반으로 하는 컨테이너이다.
		- 더블 링크드 리스트로 구현된 컨테이너, 즉 클래스 템플릿이다
		- 앞, 뒤 노드 삽입 삭제가 가능하다.
		- 각 노드는 연속적인 메모리 공간에 나열된 것이 아니라 비 연속적인 메모리 공간에 여기저기 저장되어 있지만 포인터로 각 노드를 연결하여 마치 연속된 공간에 나열한 것처럼 보일 뿐이다
		- 따라서, 각 노드에 대한 임의 접근(인덱스 접근)이 불가능하다.
		- 임의 접근이 불가능하므로 탐색 시에는 탐색하고자 하는 데이터가 나오기까지 노드가 저장한 순서대로 순회해야 한다는 점 때문에 탐색 시에는 선생 시간 복잡도가 적용된다. vector보다 불리하다.
		- 노드의 삽입 및 삭제 시에는 포인터를 통해 노드의 앞, 뒤를 연결 및 연결 해제하기만 하면 되므로 삽입 및 삭제의 시간 복잡도는 O(1) 이다. 단, 특정 위치를 찾기 위한 탐색이 필요하다면 최악의 경우 O(n) 시간이 소요될 수 있다.
		- 메모리 구조상 vector보다 오버헤드가 크며, 각 노드가 추가적인 포인터 정보를 저장해야 하므로 메모리 사용량이 상대적으로 많다.
		- 양방향 연결 리스트이므로 역순 순회가 가능하다.

	표준 시퀀스 컨테이너_deque
		- vector의 한종류로 앞에서도 삽입 가능한 기능이 추가되었다.
		- 즉, 양 끝에서 삽입 및 삭제가 가능하다. 상수 시간 복잡도
		- vector처럼 공간 삽입 및 삭제 시에는 선형적 시간이 걸려 느리다. vector보다 느림
		- vector의 일종으로 임의 접근(인덱스 접근)이 가능하다.
		- 실무 면접에서도 deque보다 vector위주로 물어보니 학원에선 vector를 사용한다.

	표준 연관 컨테이너(비 선형적)
		- 선형적이지 않은 구조 즉 일렬로 줄 지은 형태가 아닌 구조이다.
		- 대표적인 비 선형 자료구조에는 트리가 있다

	트리 자료 구조
		- 연관 컨테이너들은 트리 중에서도 자가 균형 이진 탐색 트리(레드-블랙 트리)로 구현되어 있다
		- 이는 수업 때 자세히 다루지 않고 개별적으로 자료구조와 알고리즘 공부할 때 봐둘 것.
*/