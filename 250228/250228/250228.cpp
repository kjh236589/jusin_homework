#include "pch.h"
#include<algorithm>
int main()
{

	return 0;
}
/*
	STL (standard template library)

	라이브러리 : 바이너리로 번역(컴파일)된 함수들을 모아놓은 파일
		- 코드 재사용을 위한 초창기 방법 중 하나이며, 다른 프로그램에서 사용할 수 있도록 운영체제나 소프트웨어 개발자에 의해 제공
		- 라이브러리의 대다수 함두들은 함수의 정의 및 선언들을 필요로 하기 때문에 링크되기 전 전처리기에 의해 해당 헤더 파일을 원시 프로그램에 포함시켜야 함
		- 라이브러리들은 사용자의 프로그램과 링크되어 실행이 가능한 완전한 프로그램을 이루게 됨

	1. 컨테이너 : 데이터를 저장하는 객체, 즉 자료구조를 구현해 놓은 객체
		원소 배치 방식에 따른 구분
			- 표준 시퀀스 컨테이너 : vector, deque, list, array, forward_list
			- 표준 연관 컨테이너 : set, multiset, map, multimap
			- 자동 정렬을 하지 않는 표준 연관 컨테이너 : unordered_set, unordered_multiset, unordered_map, unordered_multimap

		메모리 할당 방식에 따른 구분	
			- 배열 기반 컨테이너 : vector, deque, array
			- 노드 기반 컨테이너 : 나머지 컨테이너
	
		컨테이너 어댑터 : 기존 컨테이너의 기능 중 일부 기능만 사용 가능하며, 기능 제한이나 기능이 변형되어 있는 컨테이너 : stack, queue, priority_queue
	
		근사(almost) 컨테이너 : 템플릿으로서 조건을 만족하지 못한 컨테이너 : string, wstring
	
	2. (STL)알고리즘 : 컨테이너 원소들을 정렬, 탐색, 삭제 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿
		: 캡슐화를 적극적으로 사용하지 않은 이유는 일반화 프로그래밍에서 다수 컨테이너에게 동일한 기능이 적용 될 수 있도록 작성하기 위함
		: <algorithm> 반드시 포함시켜야 사용 가능
	
	
	3. 함수객체 : 객체를 함수처럼 사용하는 문법, () operator를 이용하여 제작, stl 알고리즘의 조건자로 사용하기 위해 제작
	
	4. 반복자(iterator) : 포인터가 아니다. 객체, 컨테이너 안에 있는 원소를 순회하며 그 원소의 접근 또는 쓰기를 하기 위한 용도의 객체
		포인터를 이용하여 사용하는 연산자가 대부분 오버로딩 되어 있음
		: 컨테이너마다 개별적으로 모두 소유하고 있음

	
	표준 시퀀스 컨테이너_vector
		- 동적 배열을 기반으로 하는 컨테이너이다.
		- 동적 배열 기반이기에 임의 접근(인덱스 접근)이 가능하다. 탐색에 용이하다.
		- 삽입 시에 앞에서 할 수 없으며 맨 끝에서부터 삽입해 나간다
		- 중간 삽입 및 삭제 시에 삽입 공간 확보, 삭제 공간 활용을 위해 해당 인덱스 이후의 원소 개수만큼 포인터 이동이 발생하기 때문에 느리다.
		원소 개수만큼의 선형적 시간 복잡도
		- 단 맨 끝에서 삽입 삭제 시에는 상수 시간 복잡도(빠르다는 이야기), 왜냐하면 맨 끝에서는 포인터 이돌할 원소들이 없기 때문이다.
		- 동적 배열이므로 배열의 크기를 넘어가는 삽입이 발생할 시에 동적 배열의 재 할당 및 현재 원소들의 복사가 일어나기 때문에 느리다.
		- vector의 원소를 삭제하여도 원소가 존재했던 메모리 공간은 남아있는다.

	표준 시퀀스 컨테이너_list
		- 노드를 기반으로 하는 컨테이너이다.
		- 더블 링크드 리스트로 구현된 컨테이너, 즉 클래스 템플릿이다
		- 앞, 뒤 노드 삽입 삭제가 가능하다.
		- 각 노드는 연속적인 메모리 공간에 나열된 것이 아니라 비 연속적인 메모리 공간에 여기저기 저장되어 있지만 포인터로 각 노드를 연결하여 마치 연속된 공간에 나열한 것처럼 보일 뿐이다
		- 따라서, 각 노드에 대한 임의 접근(인덱스 접근)이 불가능하다.
		- 임의 접근이 불가능하므로 탐색 시에는 탐색하고자 하는 데이터가 나오기까지 노드가 저장한 순서대로 순회해야 한다는 점 때문에 탐색 시에는 선생 시간 복잡도가 적용된다. vector보다 불리하다.
		- 노드의 삽입 및 삭제 시에는 포인터를 통해 노드의 앞, 뒤를 연결 및 연결 해제하기만 하면 되므로 삽입 및 삭제의 시간 복잡도는 O(1) 이다. 단, 특정 위치를 찾기 위한 탐색이 필요하다면 최악의 경우 O(n) 시간이 소요될 수 있다.
		- 메모리 구조상 vector보다 오버헤드가 크며, 각 노드가 추가적인 포인터 정보를 저장해야 하므로 메모리 사용량이 상대적으로 많다.
		- 양방향 연결 리스트이므로 역순 순회가 가능하다.

	표준 시퀀스 컨테이너_deque
		- vector의 한종류로 앞에서도 삽입 가능한 기능이 추가되었다.
		- 즉, 양 끝에서 삽입 및 삭제가 가능하다. 상수 시간 복잡도
		- vector처럼 공간 삽입 및 삭제 시에는 선형적 시간이 걸려 느리다. vector보다 느림
		- vector의 일종으로 임의 접근(인덱스 접근)이 가능하다.
		- 실무 면접에서도 deque보다 vector위주로 물어보니 학원에선 vector를 사용한다.

	표준 연관 컨테이너(비 선형적)
		- 선형적이지 않은 구조 즉 일렬로 줄 지은 형태가 아닌 구조이다.
		- 대표적인 비 선형 자료구조에는 트리가 있다

	트리 자료 구조
		- 연관 컨테이너들은 트리 중에서도 자가 균형 이진 탐색 트리(레드-블랙 트리)로 구현되어 있다
		- 이는 수업 때 자세히 다루지 않고 개별적으로 자료구조와 알고리즘 공부할 때 봐둘 것.

	노드와 간선
		트리는 노드와 간선의 집합체입니다. 노드 사이에 부모 - 자식 관계가 성립되면 간선으로 이어 그 관계를 정의합니다.

	
	트리의 구성
		노드 : 트리의 데이터를 저장하는 원소 다누이
		간선 노드와 노드를 연결하는 선, 트리의 간선은 부모-자식 관계만을 나타ㅐㅁ
		노드와 간선의 관계 : 노드의 개수가 N개임ㄴ 간선은 항상 N-1개

		Root 노드 : 트리의 첫번째 노드, 뿌리 노드라고도 불림
		Leaf 노드 : 단말 노드, 자식노드가 없는 마지막 노드 (5,7,8,9,10)
		내부 노드 : Leaf노드가 아닌 자식 노드가 있는 노드, 자식이 하나라도 있는 노드
		형제 노드 : 같은 부모의 자식노드 (7-8, 5-6, 9-10)
		선조 :루트 노드로부터 부모 노드까지의 경로 상에 있는 모든 노드 (7 : 4, 2, 1)
		후손 : 특정 노드의 아래에 있는 노드 (3 : 5,6,9,10)

		차수 : 한 노드가 가지는 자식 노드의 개수를 의미
		레벨 : 루트 노드로부터 멀리 떨어져 있는 거리, 루트 노드가 레벨 0에 해당
		높이 : 단말 노드의 높이를 1로 정의했을 때, 부모 노드로 올라갈 수록 1씩 증가하여 표현하는 값 (노드 2의 높이는 3)
		서브 트리 : 특정 노드를 기준으롷 대아 노드의 후손들만 포함한 트리 (2가 루트인 4,7,8)
		포리스트 : 트리의 집합을 말함, 여러 개의 루트 노드가 존재하는 서브 트리의 집합


		포화 이진 트리 (Full Binary Tree)
			모든 노드가 0개 또는 2개의 자식 노드를 가지는 이진 트리.
			즉, 자식이 없는 리프 노드를 제외한 모든 노드는 반드시 두 개의 자식을 가짐.

		완전 이진 트리 (Complete Binary Tree)
			마지막 레벨을 제외한 모든 레벨이 노드로 가득 차 있어야 함.
			마지막 레벨에서는 왼쪽부터 차례로 노드가 채워져 있어야 함.
			주로 배열 기반 힙(Heap) 구조에서 사용됨.

		전 이진 트리 (Perfect Binary Tree)
			모든 리프 노드가 동일한 깊이를 가지며, 모든 내부 노드는 정확히 두 개의 자식 노드를 가짐.
			포화 이진 트리의 특별한 형태로 볼 수 있음.

		편향 이진 트리 (Skewed Binary Tree)
			모든 노드가 한쪽 방향(왼쪽 또는 오른쪽)으로만 자식 노드를 가짐.
			선형 구조(Linked List)와 유사함.
			최악의 경우 탐색 시간 복잡도가 O(n)이 됨.
			종류:
			왼쪽 편향 이진 트리 (Left-Skewed Binary Tree) → 모든 노드가 왼쪽 자식만 가짐.
			오른쪽 편향 이진 트리 (Right-Skewed Binary Tree) → 모든 노드가 오른쪽 자식만 가짐.

		균형 이진 트리 (Balanced Binary Tree)
			모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 최대 1 이하로 유지되는 이진 트리.

	이진 트리의 순회 종류
		전위 순회 V-L-R
		중위 순회 L-V-R
		후의 순회 L-R-V
		레벨 순회레벨 0- 레벨1 - 레벨2
*/